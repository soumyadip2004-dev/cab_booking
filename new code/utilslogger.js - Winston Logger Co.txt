// utils/logger.js - Winston Logger Configuration
const winston = require('winston');
const path = require('path');

const logFormat = winston.format.combine(
  winston.format.timestamp(),
  winston.format.errors({ stack: true }),
  winston.format.json()
);

const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: logFormat,
  defaultMeta: { service: 'quickride-api' },
  transports: [
    new winston.transports.File({ 
      filename: path.join(__dirname, '../logs/error.log'), 
      level: 'error',
      maxsize: 5242880, // 5MB
      maxFiles: 5
    }),
    new winston.transports.File({ 
      filename: path.join(__dirname, '../logs/combined.log'),
      maxsize: 5242880, // 5MB
      maxFiles: 5
    })
  ]
});

if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: winston.format.combine(
      winston.format.colorize(),
      winston.format.simple()
    )
  }));
}

module.exports = logger;

// ======================================================

// utils/geolocation.js - Location and Distance Utilities
const haversineDistance = (lat1, lon1, lat2, lon2) => {
  const toRadians = (degree) => degree * (Math.PI / 180);
  
  const R = 6371; // Earth's radius in kilometers
  const dLat = toRadians(lat2 - lat1);
  const dLon = toRadians(lon2 - lon1);
  
  const a = 
    Math.sin(dLat/2) * Math.sin(dLat/2) +
    Math.cos(toRadians(lat1)) * Math.cos(toRadians(lat2)) * 
    Math.sin(dLon/2) * Math.sin(dLon/2);
    
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  const distance = R * c;
  
  return Math.round(distance * 100) / 100;
};

const generateCoordinates = (address) => {
  // Mock coordinates based on address (Bangalore area)
  const baseCoords = { 
    lat: 12.9716, 
    lng: 77.5946 
  };

  // Create variation based on address string
  const hash = address.split('').reduce((a, b) => {
    a = ((a << 5) - a) + b.charCodeAt(0);
    return a & a;
  }, 0);
  
  const latOffset = (Math.abs(hash) % 200) / 2000; // 0 to 0.1 degree variation
  const lngOffset = ((Math.abs(hash * 7) % 200)) / 2000;
  
  return [
    baseCoords.lng + (hash > 0 ? lngOffset : -lngOffset),
    baseCoords.lat + (hash > 0 ? latOffset : -latOffset)
  ];
};

const calculateDistance = (pickupCoords, dropCoords) => {
  const distance = haversineDistance(
    pickupCoords[1], pickupCoords[0], // lat, lng
    dropCoords[1], dropCoords[0]
  );
  
  // Add some randomness and ensure minimum distance
  const randomFactor = 0.8 + (Math.random() * 0.4); // 0.8 to 1.2
  return Math.max(Math.round(distance * randomFactor), 2); // Minimum 2km
};

const isWithinServiceArea = (coordinates) => {
  // Define service area boundaries (Bangalore area)
  const serviceBounds = {
    north: 13.2,
    south: 12.7,
    east: 77.8,
    west: 77.3
  };
  
  return (
    coordinates[1] >= serviceBounds.south &&
    coordinates[1] <= serviceBounds.north &&
    coordinates[0] >= serviceBounds.west &&
    coordinates[0] <= serviceBounds.east
  );
};

module.exports = {
  haversineDistance,
  generateCoordinates,
  calculateDistance,
  isWithinServiceArea
};

// ======================================================

// utils/pricing.js - Dynamic Pricing Engine
class PricingEngine {
  constructor() {
    this.baseRates = {
      bike: { perKm: 8, baseFare: 25 },
      auto: { perKm: 12, baseFare: 40 },
      cab: { perKm: 15, baseFare: 60 }
    };

    this.surgeFactors = {
      peak_hours: 1.5,     // 8-10 AM, 6-8 PM
      weekend: 1.2,        // Saturday, Sunday
      night: 1.3,          // 10 PM - 6 AM
      high_demand: 1.4,    // High demand areas
      weather: 1.6         // Rain/bad weather
    };
  }

  calculateBaseFare(distance, rideType) {
    const rates = this.baseRates[rideType] || this.baseRates.bike;
    const distanceFare = distance * rates.perKm;
    const totalFare = rates.baseFare + distanceFare;
    
    return {
      baseFare: rates.baseFare,
      distanceFare: distanceFare,
      total: totalFare
    };
  }

  calculateSurgeMultiplier(scheduledDateTime, pickupLocation) {
    let surgeMultiplier = 1.0;
    const date = new Date(scheduledDateTime);
    const hour = date.getHours();
    const day = date.getDay();

    // Peak hours surge (8-10 AM, 6-8 PM)
    if ((hour >= 8 && hour <= 10) || (hour >= 18 && hour <= 20)) {
      surgeMultiplier *= this.surgeFactors.peak_hours;
    }

    // Weekend surge
    if (day === 0 || day === 6) {
      surgeMultiplier *= this.surgeFactors.weekend;
    }

    // Night hours surge (10 PM - 6 AM)
    if (hour >= 22 || hour <= 6) {
      surgeMultiplier *= this.surgeFactors.night;
    }

    // High demand areas (simplified)
    const highDemandAreas = [
      'mg road', 'koramangala', 'whitefield', 'electronic city',
      'indiranagar', 'brigade road', 'commercial street'
    ];
    
    const isHighDemandArea = highDemandAreas.some(area => 
      pickupLocation.toLowerCase().includes(area)
    );
    
    if (isHighDemandArea) {
      surgeMultiplier *= this.surgeFactors.high_demand;
    }

    // Weather factor (randomly applied for demo)
    if (Math.random() < 0.1) { // 10% chance of weather surge
      surgeMultiplier *= this.surgeFactors.weather;
    }

    return Math.min(Math.round(surgeMultiplier * 100) / 100, 3.0); // Cap at 3x
  }

  calculateTaxes(subtotal) {
    // GST calculation (5% for transportation services)
    return Math.round(subtotal * 0.05);
  }
}

const pricingEngine = new PricingEngine();

const calculatePricing = ({ distance, rideType, scheduledDateTime, pickupLocation, specialRequests = [] }) => {
  const baseFareCalculation = pricingEngine.calculateBaseFare(distance, rideType);
  const surgeMultiplier = pricingEngine.calculateSurgeMultiplier(scheduledDateTime, pickupLocation);
  
  // Apply surge to base fare calculation
  const surgedBaseFare = Math.round(baseFareCalculation.baseFare * surgeMultiplier);
  const surgedDistanceFare = Math.round(baseFareCalculation.distanceFare * surgeMultiplier);
  
  let subtotal = surgedBaseFare + surgedDistanceFare;
  
  // Add special request charges
  let specialRequestCharges = 0;
  specialRequests.forEach(request => {
    switch (request.type) {
      case 'ac_required':
        specialRequestCharges += 20;
        break;
      case 'extra_luggage':
        specialRequestCharges += 15;
        break;
      case 'pet_friendly':
        specialRequestCharges += 25;
        break;
      case 'child_seat':
        specialRequestCharges += 30;
        break;
      default:
        break;
    }
  });

  subtotal += specialRequestCharges;
  
  const taxes = pricingEngine.calculateTaxes(subtotal);
  const estimatedTotal = subtotal + taxes;

  return {
    baseFare: baseFareCalculation.baseFare,
    distanceFare: baseFareCalculation.distanceFare,
    surgeMultiplier,
    surgedBaseFare,
    surgedDistanceFare,
    specialRequestCharges,
    taxes,
    estimatedTotal,
    breakdown: {
      distance,
      ratePerKm: pricingEngine.baseRates[rideType].perKm,
      minimumFare: pricingEngine.baseRates[rideType].baseFare,
      surgeApplied: surgeMultiplier > 1.0,
      specialRequests: specialRequests.length
    }
  };
};

const calculateETA = (distance, rideType) => {
  const averageSpeeds = {
    bike: 25,    // km/h in city traffic
    auto: 20,    // km/h in city traffic
    cab: 22      // km/h in city traffic
  };

  const speed = averageSpeeds[rideType] || averageSpeeds.bike;
  const timeInHours = distance / speed;
  const timeInMinutes = Math.round(timeInHours * 60);
  
  // Add buffer time for traffic
  const bufferTime = Math.round(timeInMinutes * 0.2); // 20% buffer
  
  return Math.max(timeInMinutes + bufferTime, 10); // Minimum 10 minutes
};

module.exports = {
  calculatePricing,
  calculateETA,
  PricingEngine
};

// ======================================================

// middleware/errorHandler.js - Global Error Handler
const logger = require('../utils/logger');

const errorHandler = (err, req, res, next) => {
  let error = { ...err };
  error.message = err.message;

  // Log error
  logger.error('API Error:', {
    message: err.message,
    stack: err.stack,
    url: req.originalUrl,
    method: req.method,
    ip: req.ip,
    userAgent: req.headers['user-agent']
  });

  // Mongoose bad ObjectId
  if (err.name === 'CastError') {
    const message = 'Invalid ID format';
    error = { message, statusCode: 400 };
  }

  // Mongoose duplicate key error
  if (err.code === 11000) {
    const field = Object.keys(err.keyValue)[0];
    const message = `${field} already exists`;
    error = { message, statusCode: 400 };
  }

  // Mongoose validation error
  if (err.name === 'ValidationError') {
    const message = Object.values(err.errors).map(val => val.message).join(', ');
    error = { message, statusCode: 400 };
  }

  // JWT errors
  if (err.name === 'JsonWebTokenError') {
    const message = 'Invalid token';
    error = { message, statusCode: 401 };
  }

  if (err.name === 'TokenExpiredError') {
    const message = 'Token expired';
    error = { message, statusCode: 401 };
  }

  res.status(error.statusCode || 500).json({
    success: false,
    error: error.message || 'Server Error',
    ...(process.env.NODE_ENV === 'development' && { stack: err.stack })
  });
};

module.exports = { errorHandler };

// ======================================================

// scripts/setup.js - Database Setup Script
const mongoose = require('mongoose');
const path = require('path');
const fs = require('fs');
require('dotenv').config();

const User = require('../models/User');
const Rider = require('../models/Rider');
const Ride = require('../models/Ride');

const setup = async () => {
  try {
    console.log('ğŸš€ Starting QuickRide setup...');

    // Create logs directory
    const logsDir = path.join(__dirname, '../logs');
    if (!fs.existsSync(logsDir)) {
      fs.mkdirSync(logsDir, { recursive: true });
      console.log('âœ… Created logs directory');
    }

    // Connect to MongoDB
    console.log('ğŸ“¡ Connecting to MongoDB...');
    await mongoose.connect(process.env.MONGODB_URI || 'mongodb://localhost:27017/quickride', {
      useNewUrlParser: true,
      useUnifiedTopology: true,
    });
    console.log('âœ… Connected to MongoDB');

    // Check if collections exist and create indexes
    console.log('ğŸ”§ Setting up database indexes...');
    
    await User.createIndexes();
    console.log('âœ… User indexes created');
    
    await Rider.createIndexes();
    console.log('âœ… Rider indexes created');
    
    await Ride.createIndexes();
    console.log('âœ… Ride indexes created');

    console.log('ğŸ‰ Setup completed successfully!');
    console.log('\nğŸ“‹ Next steps:');
    console.log('1. Start the server: npm run dev');
    console.log('2. Seed sample data: POST http://localhost:5000/api/admin/setup-complete-data');
    console.log('3. Open the frontend: http://localhost:5000');

  } catch (error) {
    console.error('âŒ Setup failed:', error);
  } finally {
    await mongoose.connection.close();
  }
};

if (require.main === module) {
  setup();
}

module.exports = setup;