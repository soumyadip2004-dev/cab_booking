// routes/rides.js - Ride Management Routes
const express = require('express');
const { body, validationResult, query } = require('express-validator');
const mongoose = require('mongoose');

const Ride = require('../models/Ride');
const Rider = require('../models/Rider');
const User = require('../models/User');
const { authenticateToken } = require('../middleware/auth');
const { calculateDistance, generateCoordinates } = require('../utils/geolocation');
const { calculatePricing, calculateETA } = require('../utils/pricing');
const logger = require('../utils/logger');

const router = express.Router();

// Validation middleware for booking a ride
const bookRideValidation = [
  body('passengerName')
    .trim()
    .isLength({ min: 2, max: 50 })
    .withMessage('Passenger name must be between 2-50 characters'),
  body('pickupLocation')
    .trim()
    .isLength({ min: 5, max: 200 })
    .withMessage('Pickup location must be between 5-200 characters'),
  body('dropLocation')
    .trim()
    .isLength({ min: 5, max: 200 })
    .withMessage('Drop location must be between 5-200 characters'),
  body('rideType')
    .isIn(['bike', 'auto', 'cab'])
    .withMessage('Invalid ride type'),
  body('scheduledDateTime')
    .isISO8601()
    .withMessage('Invalid date format')
    .custom((value) => {
      const scheduledDate = new Date(value);
      const now = new Date();
      const maxFutureDate = new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000); // 7 days
      
      if (scheduledDate < now) {
        throw new Error('Scheduled time cannot be in the past');
      }
      if (scheduledDate > maxFutureDate) {
        throw new Error('Cannot schedule rides more than 7 days in advance');
      }
      return true;
    })
];

// Helper function to find available riders
const findAvailableRider = async (rideType, pickupCoordinates, excludeRiderIds = []) => {
  try {
    const riders = await Rider.findAvailableNearby(
      rideType,
      pickupCoordinates[0], // longitude
      pickupCoordinates[1], // latitude
      10000 // 10km radius
    ).limit(10);

    // Filter out excluded riders
    const availableRiders = riders.filter(rider => 
      !excludeRiderIds.includes(rider._id.toString())
    );

    if (availableRiders.length === 0) {
      return null;
    }

    // Sort by rating and acceptance rate, then return the best one
    availableRiders.sort((a, b) => {
      const scoreA = (a.ratings.average * 0.7) + (a.stats.acceptanceRate * 0.3);
      const scoreB = (b.ratings.average * 0.7) + (b.stats.acceptanceRate * 0.3);
      return scoreB - scoreA;
    });

    return availableRiders[0];
  } catch (error) {
    logger.error('Error finding available rider:', error);
    return null;
  }
};

// @route   POST /api/rides/book
// @desc    Book a new ride
// @access  Private
router.post('/book', authenticateToken, bookRideValidation, async (req, res) => {
  try {
    // Check for validation errors
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        success: false,
        error: 'Validation failed',
        details: errors.array()
      });
    }

    const {
      passengerName,
      pickupLocation,
      dropLocation,
      rideType,
      scheduledDateTime,
      specialRequests = []
    } = req.body;

    logger.info(`Ride booking request from user ${req.user.userId}`, {
      pickup: pickupLocation,
      drop: dropLocation,
      rideType,
      scheduledDateTime
    });

    // Generate coordinates for pickup and drop locations
    const pickupCoordinates = generateCoordinates(pickupLocation);
    const dropCoordinates = generateCoordinates(dropLocation);

    // Calculate distance and duration
    const distance = calculateDistance(pickupCoordinates, dropCoordinates);
    const estimatedDuration = calculateETA(distance, rideType);

    // Calculate pricing
    const pricing = calculatePricing({
      distance,
      rideType,
      scheduledDateTime,
      pickupLocation,
      specialRequests
    });

    // Find available rider
    const rider = await findAvailableRider(rideType, pickupCoordinates);
    
    if (!rider) {
      return res.status(404).json({
        success: false,
        error: 'No riders available at the moment. Please try again.',
        suggestion: 'You can try booking a different vehicle type or wait a few minutes.'
      });
    }

    // Create ride
    const ride = new Ride({
      userId: req.user.userId,
      riderId: rider._id,
      passengerDetails: {
        name: passengerName,
        phone: req.user.phoneNumber
      },
      pickupLocation: {
        address: pickupLocation,
        coordinates: {
          type: 'Point',
          coordinates: pickupCoordinates
        }
      },
      dropLocation: {
        address: dropLocation,
        coordinates: {
          type: 'Point',
          coordinates: dropCoordinates
        }
      },
      rideType,
      scheduledDateTime: new Date(scheduledDateTime),
      distance: {
        estimated: distance
      },
      duration: {
        estimated: estimatedDuration
      },
      pricing,
      specialRequests,
      status: 'accepted',
      eta: {
        pickup: Math.floor(Math.random() * 10) + 3, // 3-12 minutes
        drop: estimatedDuration
      }
    });

    await ride.save();

    // Update rider availability
    rider.availability.isAvailable = false;
    rider.stats.totalRides += 1;
    rider.lastActiveAt = new Date();
    await rider.save();

    // Populate rider details for response
    await ride.populate('riderId', 'name phoneNumber vehicleDetails ratings availability');

    // Prepare response
    const response = {
      success: true,
      message: 'Ride booked successfully',
      ride: {
        id: ride._id,
        rideId: ride.rideId,
        passengerName: ride.passengerDetails.name,
        pickupLocation: ride.pickupLocation.address,
        dropLocation: ride.dropLocation.address,
        rideType: ride.rideType,
        scheduledDateTime: ride.scheduledDateTime,
        distance: ride.distance.estimated,
        duration: ride.duration.estimated,
        estimatedCost: ride.pricing.estimatedTotal,
        status: ride.status,
        eta: ride.eta,
        rider: {
          name: rider.name,
          phoneNumber: rider.phoneNumber,
          vehicleModel: rider.vehicleDetails.model,
          vehicleNumber: rider.vehicleDetails.number,
          rating: rider.ratings.average,
          vehicleInfo: `${rider.vehicleDetails.brand || ''} ${rider.vehicleDetails.model}`.trim()
        },
        pricing: {
          baseFare: ride.pricing.baseFare,
          distanceFare: ride.pricing.distanceFare,
          surgeMultiplier: ride.pricing.surgeMultiplier,
          estimatedTotal: ride.pricing.estimatedTotal,
          breakdown: ride.pricing
        }
      }
    };

    logger.info(`Ride ${ride.rideId} booked successfully`, {
      userId: req.user.userId,
      riderId: rider._id,
      estimatedCost: ride.pricing.estimatedTotal
    });

    res.status(201).json(response);

  } catch (error) {
    logger.error('Book ride error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to book ride. Please try again.',
      ...(process.env.NODE_ENV === 'development' && { details: error.message })
    });
  }
});

// @route   GET /api/rides
// @desc    Get user's rides with pagination and filters
// @access  Private
router.get('/', authenticateToken, [
  query('page').optional().isInt({ min: 1 }).withMessage('Page must be a positive integer'),
  query('limit').optional().isInt({ min: 1, max: 50 }).withMessage('Limit must be between 1-50'),
  query('status').optional().isIn(['requested', 'searching', 'accepted', 'arrived', 'started', 'completed', 'cancelled_user', 'cancelled_rider', 'cancelled_system', 'no_show']),
  query('rideType').optional().isIn(['bike', 'auto', 'cab'])
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        success: false,
        error: 'Validation failed',
        details: errors.array()
      });
    }

    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 20;
    const skip = (page - 1) * limit;

    // Build filter query
    const filter = { userId: req.user.userId };
    
    if (req.query.status) {
      filter.status = req.query.status;
    }