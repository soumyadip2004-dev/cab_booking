// routes/auth.js - Authentication Routes
const express = require('express');
const jwt = require('jsonwebtoken');
const rateLimit = require('express-rate-limit');
const { body, validationResult } = require('express-validator');

const User = require('../models/User');
const { authenticateToken } = require('../middleware/auth');
const { sendOTP } = require('../services/smsService');
const logger = require('../utils/logger');

const router = express.Router();

// Rate limiting for OTP requests
const otpLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 3, // 3 OTP requests per 15 minutes per IP
  message: {
    success: false,
    error: 'Too many OTP requests. Please try again after 15 minutes.'
  },
  standardHeaders: true,
  legacyHeaders: false,
});

// Rate limiting for OTP verification
const verifyLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5, // 5 verification attempts per 15 minutes per IP
  message: {
    success: false,
    error: 'Too many verification attempts. Please try again after 15 minutes.'
  },
  standardHeaders: true,
  legacyHeaders: false,
});

// Validation middleware
const sendOTPValidation = [
  body('phoneNumber')
    .isLength({ min: 10, max: 10 })
    .withMessage('Phone number must be 10 digits')
    .isNumeric()
    .withMessage('Phone number must contain only digits')
    .custom((value) => {
      if (!/^[6-9]\d{9}$/.test(value)) {
        throw new Error('Invalid Indian mobile number format');
      }
      return true;
    })
];

const verifyOTPValidation = [
  body('phoneNumber')
    .isLength({ min: 10, max: 10 })
    .withMessage('Phone number must be 10 digits')
    .isNumeric()
    .withMessage('Phone number must contain only digits'),
  body('otp')
    .isLength({ min: 6, max: 6 })
    .withMessage('OTP must be 6 digits')
    .isNumeric()
    .withMessage('OTP must contain only digits')
];

// Helper function to generate OTP
const generateOTP = () => {
  return Math.floor(100000 + Math.random() * 900000).toString();
};

// Helper function to generate JWT token
const generateToken = (user) => {
  return jwt.sign(
    { 
      userId: user._id, 
      phoneNumber: user.phoneNumber,
      isVerified: user.isVerified
    },
    process.env.JWT_SECRET || 'your-secret-key',
    { 
      expiresIn: process.env.JWT_EXPIRE || '7d',
      issuer: 'quickride-api',
      audience: 'quickride-app'
    }
  );
};

// @route   POST /api/auth/send-otp
// @desc    Send OTP to user's phone number
// @access  Public
router.post('/send-otp', otpLimiter, sendOTPValidation, async (req, res) => {
  try {
    // Check for validation errors
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        success: false,
        error: 'Validation failed',
        details: errors.array()
      });
    }

    const { phoneNumber } = req.body;
    logger.info(`OTP request for phone number: ${phoneNumber}`);

    // Generate OTP
    const otp = generateOTP();
    const otpExpiry = new Date(Date.now() + 10 * 60 * 1000); // 10 minutes

    // Find existing user or create new one
    let user = await User.findOne({ phoneNumber });
    
    if (user) {
      // Check if too many OTP attempts
      if (user.otp && user.otp.attempts >= 3) {
        return res.status(429).json({
          success: false,
          error: 'Too many OTP attempts. Please try again after some time.'
        });
      }

      // Update existing user's OTP
      user.otp = {
        code: otp,
        expiry: otpExpiry,
        attempts: 0
      };
      await user.save();
    } else {
      // Create new user
      user = new User({
        phoneNumber,
        otp: {
          code: otp,
          expiry: otpExpiry,
          attempts: 0
        }
      });
      await user.save();
    }

    // Send OTP via SMS
    try {
      await sendOTP(phoneNumber, otp);
      logger.info(`OTP sent successfully to ${phoneNumber}`);
    } catch (smsError) {
      logger.error(`SMS sending failed for ${phoneNumber}:`, smsError);
      // Continue without failing the request
    }

    res.json({
      success: true,
      message: 'OTP sent successfully',
      // Only include OTP in development environment
      ...(process.env.NODE_ENV === 'development' && { otp }),
      expiresIn: 10 * 60 // 10 minutes in seconds
    });

  } catch (error) {
    logger.error('Send OTP error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to send OTP. Please try again.',
      ...(process.env.NODE_ENV === 'development' && { details: error.message })
    });
  }
});

// @route   POST /api/auth/verify-otp
// @desc    Verify OTP and login user
// @access  Public
router.post('/verify-otp', verifyLimiter, verifyOTPValidation, async (req, res) => {
  try {
    // Check for validation errors
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        success: false,
        error: 'Validation failed',
        details: errors.array()
      });
    }

    const { phoneNumber, otp } = req.body;
    logger.info(`OTP verification attempt for phone number: ${phoneNumber}`);

    // Find user with OTP details
    const user = await User.findOne({ phoneNumber }).select('+otp');
    
    if (!user) {
      return res.status(400).json({
        success: false,
        error: 'User not found. Please request a new OTP.'
      });
    }

    // Check if OTP exists and not expired
    if (!user.otp || !user.otp.code || !user.otp.expiry) {
      return res.status(400).json({
        success: false,
        error: 'OTP not found. Please request a new OTP.'
      });
    }

    if (user.otp.expiry < new Date()) {
      return res.status(400).json({
        success: false,
        error: 'OTP has expired. Please request a new OTP.'
      });
    }

    // Increment OTP attempts
    user.incrementOTPAttempts();

    // Check if too many attempts
    if (user.otp.attempts > 5) {
      await user.save();
      return res.status(429).json({
        success: false,
        error: 'Too many invalid attempts. Please request a new OTP.'
      });
    }

    // Verify OTP
    const isOTPValid = await user.verifyOTP(otp);
    
    if (!isOTPValid) {
      await user.save();
      return res.status(400).json({
        success: false,
        error: `Invalid OTP. ${5 - user.otp.attempts} attempts remaining.`
      });
    }

    // OTP is valid - mark user as verified and clear OTP
    user.isVerified = true;
    user.lastLogin = new Date();
    user.clearOTP();
    await user.save();

    // Generate JWT token
    const token = generateToken(user);

    logger.info(`User ${phoneNumber} logged in successfully`);

    res.json({
      success: true,
      message: 'Login successful',
      token,
      expiresIn: 7 * 24 * 60 * 60, // 7 days in seconds
      user: {
        id: user._id,
        phoneNumber: user.phoneNumber,
        name: user.name,
        email: user.email,
        isVerified: user.isVerified,
        createdAt: user.createdAt,
        stats: user.stats
      }
    });

  } catch (error) {
    logger.error('Verify OTP error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to verify OTP. Please try again.',
      ...(process.env.NODE_ENV === 'development' && { details: error.message })
    });
  }
});

// @route   POST /api/auth/resend-otp
// @desc    Resend OTP to user's phone number
// @access  Public
router.post('/resend-otp', otpLimiter, [
  body('phoneNumber')
    .isLength({ min: 10, max: 10 })
    .withMessage('Phone number must be 10 digits')
    .isNumeric()
    .withMessage('Phone number must contain only digits')
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        success: false,
        error: 'Validation failed',
        details: errors.array()
      });
    }

    const { phoneNumber } = req.body;

    // Find user
    const user = await User.findOne({ phoneNumber });
    if (!user) {
      return res.status(404).json({
        success: false,
        error: 'User not found. Please register first.'
      });
    }

    // Generate new OTP
    const otp = generateOTP();
    const otpExpiry = new Date(Date.now() + 10 * 60 * 1000);

    user.otp = {
      code: otp,
      expiry: otpExpiry,
      attempts: 0
    };
    await user.save();

    // Send OTP
    try {
      await sendOTP(phoneNumber, otp);
      logger.info(`OTP resent successfully to ${phoneNumber}`);
    } catch (smsError) {
      logger.error(`SMS resending failed for ${phoneNumber}:`, smsError);
    }

    res.json({
      success: true,
      message: 'OTP resent successfully',
      ...(process.env.NODE_ENV === 'development' && { otp }),
      expiresIn: 10 * 60
    });

  } catch (error) {
    logger.error('Resend OTP error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to resend OTP. Please try again.'
    });
  }
});

// @route   GET /api/auth/me
// @desc    Get current user info
// @access  Private
router.get('/me', authenticateToken, async (req, res) => {
  try {
    const user = await User.findById(req.user.userId);
    
    if (!user) {
      return res.status(404).json({
        success: false,
        error: 'User not found'
      });
    }

    res.json({
      success: true,
      user: {
        id: user._id,
        phoneNumber: user.phoneNumber,
        name: user.name,
        email: user.email,
        isVerified: user.isVerified,
        profile: user.profile,
        preferences: user.preferences,
        stats: user.stats,
        createdAt: user.createdAt,
        lastLogin: user.lastLogin
      }
    });

  } catch (error) {
    logger.error('Get user info error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to get user information'
    });
  }
});

// @route   POST /api/auth/logout
// @desc    Logout user (blacklist token if using token blacklisting)
// @access  Private
router.post('/logout', authenticateToken, async (req, res) => {
  try {
    // In a more advanced implementation, you might want to blacklist the token
    // For now, we'll just return a success message as the client will remove the token
    
    logger.info(`User ${req.user.phoneNumber} logged out`);
    
    res.json({
      success: true,
      message: 'Logged out successfully'
    });

  } catch (error) {
    logger.error('Logout error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to logout'
    });
  }
});

// @route   POST /api/auth/refresh-token
// @desc    Refresh JWT token
// @access  Private
router.post('/refresh-token', authenticateToken, async (req, res) => {
  try {
    const user = await User.findById(req.user.userId);
    
    if (!user || !user.isVerified) {
      return res.status(401).json({
        success: false,
        error: 'User not found or not verified'
      });
    }

    // Generate new token
    const token = generateToken(user);

    res.json({
      success: true,
      message: 'Token refreshed successfully',
      token,
      expiresIn: 7 * 24 * 60 * 60 // 7 days in seconds
    });

  } catch (error) {
    logger.error('Refresh token error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to refresh token'
    });
  }
});

module.exports = router;